//! Map generation and rendering.

mod chunk;
pub mod chunk_position;
pub mod config;
mod tile_kind;

use std::time::Instant;

use bevy::prelude::*;
use bevy::utils::{HashMap, HashSet};
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};
use worldgen::noise::perlin::PerlinNoise;
use worldgen::noisemap::{self, NoiseMapGenerator, Seed, Step};
use worldgen::world::Size;

use self::chunk::Chunk;
use self::chunk_position::ChunkPosition;
use self::config::MapConfig;
use crate::get_single;
use crate::player::sprite_movement;

pub fn map_plugin(app: &mut App) {
    app.add_event::<ChunkReloadEvent>()
        .init_resource::<Map>()
        .init_resource::<MapConfig>()
        .init_resource::<NoiseMap>()
        .init_resource::<UnspawnedChunks>()
        .init_state::<ChunkBorderState>()
        .add_systems(
            Update,
            (
                (update_noisemap, chunk_unload).run_if(on_event::<ChunkReloadEvent>()),
                calculate_chunks,
                spawn_chunks,
            )
                .chain()
                .after(sprite_movement),
        );
}

#[derive(States, Debug, Default, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ChunkBorderState {
    Shown,
    #[default]
    Hidden,
}

impl ChunkBorderState {
    pub const fn next(self) -> Self {
        match self {
            Self::Shown => Self::Hidden,
            Self::Hidden => Self::Shown,
        }
    }
}

impl From<ChunkBorderState> for bool {
    fn from(value: ChunkBorderState) -> Self {
        match value {
            ChunkBorderState::Shown => true,
            ChunkBorderState::Hidden => false,
        }
    }
}

#[derive(Event)]
pub struct ChunkReloadEvent;

#[derive(Resource, Deref, DerefMut)]
struct NoiseMap(noisemap::NoiseMap<PerlinNoise>);

impl FromWorld for NoiseMap {
    fn from_world(world: &mut World) -> Self {
        let config = world
            .get_resource::<MapConfig>()
            .expect("NoiseMap must be initialised before MapConfig");

        let noise = PerlinNoise::new();

        Self(
            noisemap::NoiseMap::new(noise)
        .set(Seed::of(rand::random::<i64>())) // Todo: Convert this into a proper seed system
        .set(Size::of(config.chunk_tile_count as i64, config.chunk_tile_count as i64))
        .set(Step::of(0.01, 0.01)),
        )
    }
}

#[derive(Resource, Default, Deref, DerefMut)]
struct Map(HashMap<ChunkPosition, Entity>);

/// A list of unspawned [`Chunks`](Chunk) that have been generated by
/// [`calculate_chunks`] that will be then generated and spawned by [`spawn_chunks`].
#[derive(Resource, Default, Deref, DerefMut)]
struct UnspawnedChunks(Vec<ChunkPosition>);

/// Update the [`NoiseMap`] if its config has changed.
fn update_noisemap(mut noisemap: ResMut<NoiseMap>, config: Res<MapConfig>) {
    noisemap.0 = noisemap.set(Size::of(
        config.chunk_tile_count as i64,
        config.chunk_tile_count as i64,
    ));
}

/// If a [`ChunkReloadEvent`] is created, all chunks get unloaded & despawned to then be reloaded.
///
/// Requires to be run with `.run_if(on_event::<ChunkReloadEvent>())` otherwise chunks will be unloaded every frame.
fn chunk_unload(
    mut commands: Commands,
    mut ev_chunk_reload: EventReader<ChunkReloadEvent>,
    mut map: ResMut<Map>,
) {
    debug!("Unloading all chunks");
    for (_, chunk) in map.iter() {
        commands.entity(*chunk).despawn_recursive();
    }
    map.clear();
    ev_chunk_reload.clear();
}

/// System to spawn and despawn the games chunks depending on the [`Camera`] transform.
fn calculate_chunks(
    mut commands: Commands,
    mut map: ResMut<Map>,
    mut unspawned_chunks: ResMut<UnspawnedChunks>,
    config: Res<MapConfig>,
    camera_transform: Query<&Transform, With<Camera>>,
    camera_projection: Query<&OrthographicProjection, With<Camera>>,
) {
    let camera_transform = get_single!(camera_transform);

    let camera_projection = get_single!(camera_projection);

    let (width, height) = (
        camera_projection.area.width(),
        camera_projection.area.height(),
    );

    // Amount of chunks needed to fill the screen vertically and horizontally.
    let horizontal_chunk_count = (width / config.chunk_size()) as i32 + 1;
    let vertical_chunk_count = (height / config.chunk_size()) as i32 + 1;

    // The chunk position of where the centre of the camera is.
    let camera_pos = ChunkPosition::from_xy(
        (
            camera_transform.translation.x,
            camera_transform.translation.y,
        ),
        &config,
    );

    let start_x = camera_pos.x - horizontal_chunk_count / 2;
    let end_x = camera_pos.x + horizontal_chunk_count / 2;
    let start_y = camera_pos.y - vertical_chunk_count / 2;
    let end_y = camera_pos.y + vertical_chunk_count / 2;

    let mut grid =
        HashSet::with_capacity(((horizontal_chunk_count * vertical_chunk_count) as usize) * 2);

    // Todo: fix the math above so the added positions isnt needed.
    for x in start_x - 1..=end_x + 2 {
        for y in start_y - 1..=end_y + 2 {
            grid.insert(ChunkPosition { x, y });
        }
    }

    let chunk_positions: HashSet<_> = map.keys().copied().collect();

    // Chunks that are going to be on screen and need to be spawned.
    unspawned_chunks.0 = grid
        .difference(&chunk_positions)
        .copied()
        .collect::<Vec<ChunkPosition>>();

    // Chunks that are no longer on screen and need to be despawned.
    let to_despawn: Vec<_> = chunk_positions.difference(&grid).copied().collect();

    for (position, entity) in map.clone() {
        if to_despawn.contains(&position) {
            commands.entity(entity).despawn_recursive();
            map.remove(&position);
        }
    }
}

/// Takes the chunk positions that were calculated in [`calculate_chunks()`] and generates and spawns them.
fn spawn_chunks(
    mut commands: Commands,
    mut unspawned_chunks: ResMut<UnspawnedChunks>,
    mut map: ResMut<Map>,
    mut assets: ResMut<Assets<Image>>,
    config: Res<MapConfig>,
    noisemap: Res<NoiseMap>,
    chunk_borders: Res<State<ChunkBorderState>>,
) {
    if unspawned_chunks.is_empty() {
        return;
    }

    let start = Instant::now();

    let chunk_package: Vec<(ChunkPosition, Chunk, Image)> = unspawned_chunks
        .par_iter()
        .map(|position| {
            let chunk = Chunk::new(*position, &noisemap, &config);
            let texture = chunk.generate_texture_image(&config, *chunk_borders.get());
            (*position, chunk, texture)
        })
        .collect();

    let count = chunk_package.len();

    for (position, chunk, texture) in chunk_package {
        let texture = assets.add(texture);
        chunk.render(&mut commands, &mut map, &config, texture, position);
    }

    unspawned_chunks.clear();

    let end = Instant::now();

    debug!(
        "Spent {:?} spawning {} chunks, for a total of {} loaded",
        end - start,
        count,
        map.keys().len()
    );
}
